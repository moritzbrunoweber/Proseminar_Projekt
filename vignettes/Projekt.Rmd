---
title: "Projekt"
output: html_document
---

```{r}
library(ncdf4)
library(terra)
library(here)
library(ggplot2)
library(sf)
library(rnaturalearth)
library(rnaturalearthdata)
```

## Area of Interest

```{r}
coords <- matrix(c(
  -77.0000000,  6.0000000,   # Upper Left
  -48.0000000,  6.0000000,   # Upper Right
  -48.0000000, -18.0000000,   # Lower Right
  -77.0000000, -18.0000000,   # Lower Left
  -77.0000000,  6.0000000    # zurück zum Startpunkt
), ncol = 2, byrow = TRUE)

polygon_sf <- st_sf(
  geometry = st_sfc(st_polygon(list(coords))),
  crs = 4326
)

world <- ne_countries(scale = "medium", returnclass = "sf")

fig_aoi <- ggplot() +
  geom_sf(data = world, fill = "gray90", color = "gray50") +
  geom_sf(data = polygon_sf, fill = "lightblue", color = "darkblue", alpha = 0.6, size = 1) +
  coord_sf(
    xlim = c(-80, -30),
    ylim = c(-20, 15),
    expand = FALSE
  ) +
  labs(
    title = "Area of Interest",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_minimal()

ggsave(
  filename = here("fig", "area_of_interest.png"),
  plot = fig_aoi,
  width = 8,
  height = 6,
  dpi = 300
)
```

## Data Processing TWS

```{r}
# Define path
file_path <- "C:/Users/Moritz.weber/Desktop/lokale Dateien/Uni/HS2025/Proseminar_Applied_Geodata_Science/data_external/GRAVIS-3_COSTG_0200_TWS_GRID_GFZ_0001.nc"

tws <- nc_open(file_path)

structure(tws)

# extract time
time_vals <- ncvar_get(tws, "time")

# Attribute der Zeitvariable holen
time_units <- ncatt_get(tws, "time", "units")$value
calendar <- ncatt_get(tws, "time", "calendar")$value

# Ausgabe prüfen
time_units
calendar
head(time_vals)

# Basiszeitpunkt aus den Attributen
origin <- as.POSIXct("2002-04-18 00:00:00", tz = "UTC")

# Zeitwerte (in Tagen) zu Datum umrechnen
time_dates <- origin + time_vals * 86400  # 86400 Sekunden pro Tag

# Kontrolle
head(time_dates)
tail(time_dates)

# Zeitraum definieren 2003-2004
start_date1 <- as.POSIXct("2003-03-01", tz = "UTC")
end_date1   <- as.POSIXct("2004-03-31", tz = "UTC")

# Index der gewünschten Zeitstufen finden
sel_idx1 <- which(time_dates >= start_date1 & time_dates <= end_date1)

# Kontrolle: welche Zeitstufen sind das?
time_dates[sel_idx1]

# Zeitraum definieren 2024-2025
start_date2 <- as.POSIXct("2024-03-01", tz = "UTC")
end_date2   <- as.POSIXct("2025-03-31", tz = "UTC")

# Index der gewünschten Zeitstufen finden
sel_idx2 <- which(time_dates >= start_date2 & time_dates <= end_date2)

# Kontrolle: welche Zeitstufen sind das?
time_dates[sel_idx2]


# Alle Zeitstufen laden (nur tws)
tws_rast <- rast(file_path)

# Subset für March 2003 – March 2004
tws1 <- tws_rast[[sel_idx1]]

# Zeitinformationen hinzufügen
time(tws1) <- time_dates[sel_idx1]

# Kontrolle
tws1

# Subset für March 2024 – March 2025
tws2 <- tws_rast[[sel_idx2]]

# Zeitinformationen hinzufügen
time(tws2) <- time_dates[sel_idx2]

# Kontrolle
tws2

tws1_mean <- mean(tws1, na.rm = TRUE)

plot(tws1_mean, main = "Mean TWS (Mar 2003 – Mar 2004)")

tws2_mean <- mean(tws2, na.rm = TRUE)

plot(tws2_mean, main = "Mean TWS (Mar 2024 – Mar 2025)")

# GRACE-Daten: von 0–360° auf -180–180° verschieben
tws1_mean_180 <- terra::rotate(tws1_mean)
tws2_mean_180 <- terra::rotate(tws2_mean)

# Kontrolle der neuen Extents
ext(tws1_mean_180)
ext(tws2_mean_180)

# Polygon bleibt unverändert
polygon_vect <- vect(polygon_sf)

# Crop und Mask mit transformierten Daten
tws1_aoi <- mask(crop(tws1_mean_180, polygon_vect), polygon_vect)
tws2_aoi <- mask(crop(tws2_mean_180, polygon_vect), polygon_vect)

# Plotten
plot(tws1_aoi, main = "Mean TWS (Mar 2003 – Mar 2004) – AOI", col = viridis::viridis(100))
plot(st_geometry(polygon_sf), add = TRUE, border = "red", lwd = 2)

plot(tws2_aoi, main = "Mean TWS (Mar 2024 – Mar 2025) – AOI", col = viridis::viridis(100))
plot(st_geometry(polygon_sf), add = TRUE, border = "red", lwd = 2)


# Zeitreihe erstellen für Maxima und Minima
```

# Data processing tree cover
```{r}

library(terra)

process_MOD44B_treecover <- function(hdf_folder, aoi, output_file) {
  # === Alle HDF-Dateien im Ordner auflisten ===
  hdf_files <- list.files(hdf_folder, pattern = "\\.hdf$", full.names = TRUE)
  if(length(hdf_files) == 0) stop("Keine HDF-Dateien im Ordner gefunden!")
  
  # === Tree Cover Layer (Percent_Tree_Cover) aus allen HDF-Dateien laden ===
  tree_rasters <- lapply(hdf_files, function(f) {
    sds_path <- sprintf('HDF4_EOS:EOS_GRID:"%s":MOD44B_250m_GRID:Percent_Tree_Cover', f)
    rast(sds_path)
  })
  
  # === Mosaik erstellen ===
  mosaic_tree <- do.call(mosaic, tree_rasters)
  
  # === CRS prüfen und AOI ggf. reprojizieren ===
  if (!identical(crs(mosaic_tree), crs(aoi))) {
    aoi <- project(aoi, crs(mosaic_tree))
  }
  
  # === Zuschneiden und maskieren ===
  tree_crop <- crop(mosaic_tree, aoi)
  tree_masked <- mask(tree_crop, aoi)
  
  # === Plot & speichern ===
  plot(tree_masked, main = paste("MOD44B Tree Cover -", output_file))
  writeRaster(tree_masked, output_file, overwrite = TRUE)
  
  return(tree_masked)
}


file_path_m1 <- "C:/Users/Moritz.weber/Desktop/lokale Dateien/Uni/HS2025/Proseminar_Applied_Geodata_Science/data_external/tree_cover_new/2000"
file_path_m2 <- "C:/Users/Moritz.weber/Desktop/lokale Dateien/Uni/HS2025/Proseminar_Applied_Geodata_Science/data_external/tree_cover_new/2024"

# Tree Cover für 2000
tree_2000 <- process_MOD44B_treecover(file_path_m1, polygon_vect, "MOD44B_TreeCover_2000_AOI.tif")

# Tree Cover für 2024
tree_2024 <- process_MOD44B_treecover(file_path_m2, polygon_vect, "MOD44B_TreeCover_2024_AOI.tif")


```


```{r}
library(terra)

# === Pfad zu deinen MOD44B HDF-Dateien ===
pfad <- "C:/Users/Moritz.weber/Desktop/lokale Dateien/Uni/HS2025/Proseminar_Applied_Geodata_Science/data_external/tree_cover_new/2000"

# === Alle .hdf-Dateien auflisten ===
hdf_files <- list.files(pfad, pattern = "\\.hdf$", full.names = TRUE)

# === Tree Cover Layer (Percent_Tree_Cover) laden ===
tree_rasters <- lapply(hdf_files, function(f) {
  sds_path <- sprintf('HDF4_EOS:EOS_GRID:"%s":MOD44B_250m_GRID:Percent_Tree_Cover', f)
  rast(sds_path)
})

# === Mosaik erstellen ===
mosaic_tree <- do.call(mosaic, tree_rasters)

# === CRS prüfen und AOI ggf. reprojizieren ===
if (!identical(crs(mosaic_tree), crs(polygon_vect))) {
  polygon_vect <- project(polygon_vect, crs(mosaic_tree))
}

# === Zuschneiden und maskieren ===
tree_crop <- crop(mosaic_tree, polygon_vect)
tree_masked <- mask(tree_crop, polygon_vect)

# === Plot und speichern ===
plot(tree_masked, main = "MOD44B Tree Cover (AOI)")
writeRaster(tree_masked, "MOD44B_TreeCover_AOI.tif", overwrite = TRUE)


```

